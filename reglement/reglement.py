import discord
from redbot.core import commands, Config, checks
from redbot.core.utils.menus import menu, DEFAULT_CONTROLS
import asyncio
import datetime

class AccepterReglementView(discord.ui.View):
    def __init__(self, cog):
        super().__init__(timeout=None)  # Le bouton reste actif ind√©finiment
        self.cog = cog
        
    @discord.ui.button(label="J'accepte le r√®glement", style=discord.ButtonStyle.success, custom_id="accepter_reglement")
    async def accepter_button(self, interaction: discord.Interaction, button: discord.ui.Button):
        """R√©agit quand un utilisateur clique sur le bouton d'acceptation"""
        await self.cog.handle_reglement_accept(interaction)

class Reglement(commands.Cog):
    """Syst√®me de r√®glement pour serveur communautaire Discord"""

    def __init__(self, bot):
        self.bot = bot
        self.config = Config.get_conf(self, identifier=156465489412, force_registration=True)
        
        default_guild = {
            "reglement": {
                "introduction": "Bienvenue sur Time 2 Clutch ! Afin de garantir une exp√©rience agr√©able pour tous et toutes, nous vous demandons de respecter les r√®gles suivantes (tout manquement pourra entra√Æner des sanctions allant du simple avertissement au bannissement d√©finitif ‚ö†Ô∏è)",
                "sections": {
                    "1": {
                        "titre": "Respect et bonne conduite",
                        "contenu": "‚Ä¢ Le respect entre membres est primordial. Aucune forme d'insulte, harc√®lement, discrimination ou discours haineux ne sera tol√©r√©e.\n‚Ä¢ Les d√©bats sont autoris√©s tant qu'ils restent courtois et respectueux.\n‚Ä¢ L'usage excessif de majuscules, spam ou flood est interdit."
                    },
                    "2": {
                        "titre": "Contenus et comportements interdits",
                        "contenu": "‚Ä¢ Tout contenu NSFW (pornographique, gore, choquant) est strictement interdit.\n‚Ä¢ La promotion de cheats, hacks ou toute autre pratique ill√©gale est interdite.\n‚Ä¢ Les discussions sur des sujets sensibles (politique, religion, etc.) doivent √™tre abord√©es avec pr√©caution ou √©vit√©es."
                    },
                    "3": {
                        "titre": "Organisation des salons",
                        "contenu": "‚Ä¢ Veuillez respecter les cat√©gories et utiliser les salons appropri√©s pour vos discussions.\n‚Ä¢ L'utilisation des salons vocaux doit se faire dans le respect des autres utilisateurs (pas de cris, bruits de fond excessifs, etc.).\n‚Ä¢ Les pseudos et avatars offensants ou inappropri√©s ne sont pas autoris√©s."
                    },
                    "4": {
                        "titre": "Publicit√© et autopromotion",
                        "contenu": "‚Ä¢ La publicit√© pour d'autres serveurs Discord est interdite sauf autorisation de l'administration.\n‚Ä¢ L'autopromotion (cha√Ænes YouTube, Twitch, etc.) est tol√©r√©e uniquement dans les salons d√©di√©s."
                    },
                    "5": {
                        "titre": "Comportement en jeu",
                        "contenu": "‚Ä¢ Jouez de mani√®re fair-play, toute triche ou comportement toxique en jeu pourra entra√Æner des sanctions sur le serveur.\n‚Ä¢ √âvitez le rage-quit ou les comportements nuisibles envers votre √©quipe."
                    },
                    "6": {
                        "titre": "R√¥le et responsabilit√©s du staff",
                        "contenu": "‚Ä¢ Le staff est l√† pour garantir le bon fonctionnement du serveur. Leurs d√©cisions doivent √™tre respect√©es.\n‚Ä¢ En cas de probl√®me, contactez le support en cr√©ant un ticket.\n‚Ä¢ Tout abus ou contournement des r√®gles sera sanctionn√©."
                    }
                },
                "conclusion": "En rejoignant ce serveur, vous acceptez ce r√®glement.\n\nL'√©quipe de mod√©ration se r√©serve le droit de modifier ce r√®glement √† tout moment.\n\nMerci de votre compr√©hension et bon jeu √† tous ! üéÆ",
            },
            "reglement_channel_id": None,
            "reglement_message_id": None,
            "role_acceptation_id": None,
            "logs_channel_id": None,
            "derniere_maj": None,
        }
        
        self.config.register_guild(**default_guild)
        self.accept_view = AccepterReglementView(self)
        
    async def handle_reglement_accept(self, interaction):
        """Traite l'interaction lorsqu'un utilisateur accepte le r√®glement"""
        guild = interaction.guild
        guild_config = self.config.guild(guild)
        role_id = await guild_config.role_acceptation_id()
        logs_id = await guild_config.logs_channel_id()
        
        if not role_id:
            return await interaction.response.send_message("‚ö†Ô∏è Aucun r√¥le n'est configur√© pour l'acceptation du r√®glement.", ephemeral=True)
            
        role = guild.get_role(role_id)
        if not role:
            return await interaction.response.send_message("‚ö†Ô∏è Le r√¥le configur√© est introuvable. Veuillez contacter un administrateur.", ephemeral=True)
            
        # Attribuer le r√¥le
        try:
            await interaction.user.add_roles(role, reason="Acceptation du r√®glement")
            await interaction.response.send_message("‚úÖ Merci d'avoir accept√© le r√®glement! Vous avez maintenant acc√®s au serveur.", ephemeral=True)
            
            # Envoyer un log
            if logs_id:
                logs_channel = guild.get_channel(logs_id)
                if logs_channel:
                    log_embed = discord.Embed(
                        title="üìù Acceptation du r√®glement",
                        description=f"{interaction.user.mention} a accept√© le r√®glement.",
                        color=discord.Color.green(),
                        timestamp=datetime.datetime.now()
                    )
                    log_embed.set_author(name=str(interaction.user), icon_url=interaction.user.display_avatar.url if interaction.user.display_avatar else None)
                    log_embed.set_footer(text=f"ID: {interaction.user.id}")
                    await logs_channel.send(embed=log_embed)
                    
        except discord.Forbidden:
            await interaction.response.send_message("‚ùå Je n'ai pas la permission d'attribuer ce r√¥le. Veuillez contacter un administrateur.", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"‚ùå Une erreur est survenue: {str(e)}", ephemeral=True)

    def cog_unload(self):
        """Nettoyage lors du d√©chargement du cog"""
        self.bot.loop.create_task(self.accept_view.stop())

    @commands.group(name="reglement")
    async def reglement(self, ctx):
        """Commandes li√©es au r√®glement du serveur"""
        pass

    @reglement.command(name="afficher")
    async def afficher_reglement(self, ctx):
        """Affiche le r√®glement complet du serveur"""
        reglement_data = await self.config.guild(ctx.guild).reglement()
        
        embeds = []
        
        # Embed d'introduction
        intro_embed = discord.Embed(
            title="üìú R√®glement du serveur",
            description=reglement_data["introduction"],
            color=discord.Color.blue()
        )
        intro_embed.set_thumbnail(url=ctx.guild.icon.url if ctx.guild.icon else None)
        intro_embed.set_footer(text=f"Serveur {ctx.guild.name}", icon_url=ctx.guild.icon.url if ctx.guild.icon else None)
        embeds.append(intro_embed)
        
        # Embeds pour chaque section
        for num, section in reglement_data["sections"].items():
            section_embed = discord.Embed(
                title=f"Section {num}: {section['titre']}",
                description=section["contenu"],
                color=discord.Color.blue()
            )
            embeds.append(section_embed)
        
        # Embed de conclusion
        conclusion_embed = discord.Embed(
            title="Conclusion et acceptation",
            description=reglement_data["conclusion"],
            color=discord.Color.blue()
        )
        
        derniere_maj = await self.config.guild(ctx.guild).derniere_maj()
        if derniere_maj:
            conclusion_embed.set_footer(text=f"Derni√®re mise √† jour: {derniere_maj}")
            
        embeds.append(conclusion_embed)
        
        await menu(ctx, embeds, DEFAULT_CONTROLS)
        
    @reglement.command(name="section")
    async def afficher_section(self, ctx, numero: str):
        """Affiche une section sp√©cifique du r√®glement
        
        Exemple: !reglement section 2
        """
        reglement_data = await self.config.guild(ctx.guild).reglement()
        
        if numero not in reglement_data["sections"]:
            return await ctx.send("‚ùå Cette section n'existe pas dans le r√®glement.")
        
        section = reglement_data["sections"][numero]
        
        embed = discord.Embed(
            title=f"Section {numero}: {section['titre']}",
            description=section["contenu"],
            color=discord.Color.blue()
        )
        embed.set_footer(text=f"R√®glement de {ctx.guild.name}")
        
        await ctx.send(embed=embed)
        
    @reglement.command(name="recherche")
    async def recherche_reglement(self, ctx, *, terme: str):
        """Recherche un terme dans le r√®glement
        
        Exemple: !reglement recherche spam
        """
        reglement_data = await self.config.guild(ctx.guild).reglement()
        resultats = []
        
        # Recherche dans l'introduction
        if terme.lower() in reglement_data["introduction"].lower():
            resultats.append(("Introduction", reglement_data["introduction"]))
            
        # Recherche dans les sections
        for num, section in reglement_data["sections"].items():
            if terme.lower() in section["titre"].lower() or terme.lower() in section["contenu"].lower():
                resultats.append((f"Section {num}: {section['titre']}", section["contenu"]))
                
        # Recherche dans la conclusion
        if terme.lower() in reglement_data["conclusion"].lower():
            resultats.append(("Conclusion", reglement_data["conclusion"]))
            
        if not resultats:
            return await ctx.send(f"‚ùå Aucun r√©sultat trouv√© pour '{terme}'.")
            
        embeds = []
        for titre, contenu in resultats:
            embed = discord.Embed(
                title=titre,
                description=contenu,
                color=discord.Color.green()
            )
            # On surligne le terme recherch√©
            embed.set_footer(text=f"Recherche: '{terme}'")
            embeds.append(embed)
            
        await menu(ctx, embeds, DEFAULT_CONTROLS)

    @checks.admin_or_permissions(manage_guild=True)
    @reglement.command(name="configurer")
    async def configurer_reglement(self, ctx):
        """Configure les param√®tres du r√®glement (Admin uniquement)"""
        # Configuration interactive du r√®glement
        await ctx.send("‚öôÔ∏è **Configuration du syst√®me de r√®glement**\n"
                       "Veuillez r√©pondre aux questions suivantes pour configurer le r√®glement.\n"
                       "Vous pouvez r√©pondre `annuler` √† tout moment pour annuler le processus.")

        # Fonction v√©rification r√©ponse
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel

        # Canal du r√®glement
        await ctx.send("üìù Dans quel canal voulez-vous publier le r√®glement ? Mentionnez le canal ou indiquez son ID.")
        try:
            reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
            if reponse.content.lower() == "annuler":
                return await ctx.send("‚ùå Configuration annul√©e.")
                
            # Extraction du canal
            if reponse.channel_mentions:
                channel = reponse.channel_mentions[0]
            else:
                try:
                    channel_id = int(reponse.content.strip())
                    channel = ctx.guild.get_channel(channel_id)
                    if not channel:
                        return await ctx.send("‚ùå Canal introuvable. Configuration annul√©e.")
                except ValueError:
                    return await ctx.send("‚ùå Canal invalide. Configuration annul√©e.")
                    
            await self.config.guild(ctx.guild).reglement_channel_id.set(channel.id)
            
            # R√¥le d'acceptation
            await ctx.send("üîë Quel r√¥le souhaitez-vous attribuer aux membres qui acceptent le r√®glement ? "
                           "Mentionnez le r√¥le ou indiquez son ID. R√©pondez `aucun` si vous ne voulez pas utiliser cette fonction.")
            reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
            if reponse.content.lower() == "annuler":
                return await ctx.send("‚ùå Configuration annul√©e.")
                
            if reponse.content.lower() != "aucun":
                # Extraction du r√¥le
                if reponse.role_mentions:
                    role = reponse.role_mentions[0]
                    await self.config.guild(ctx.guild).role_acceptation_id.set(role.id)
                else:
                    try:
                        role_id = int(reponse.content.strip())
                        role = ctx.guild.get_role(role_id)
                        if not role:
                            await ctx.send("‚ö†Ô∏è R√¥le introuvable. La fonction d'acceptation sera d√©sactiv√©e.")
                            await self.config.guild(ctx.guild).role_acceptation_id.set(None)
                        else:
                            await self.config.guild(ctx.guild).role_acceptation_id.set(role.id)
                    except ValueError:
                        await ctx.send("‚ö†Ô∏è ID de r√¥le invalide. La fonction d'acceptation sera d√©sactiv√©e.")
                        await self.config.guild(ctx.guild).role_acceptation_id.set(None)
            else:
                await self.config.guild(ctx.guild).role_acceptation_id.set(None)
                
            # Canal de logs
            await ctx.send("üìã Dans quel canal voulez-vous envoyer les logs d'acceptation du r√®glement ? "
                           "Mentionnez le canal ou indiquez son ID. R√©pondez `aucun` si vous ne voulez pas utiliser cette fonction.")
            reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
            if reponse.content.lower() == "annuler":
                return await ctx.send("‚ùå Configuration annul√©e.")
                
            if reponse.content.lower() != "aucun":
                # Extraction du canal
                if reponse.channel_mentions:
                    logs_channel = reponse.channel_mentions[0]
                    await self.config.guild(ctx.guild).logs_channel_id.set(logs_channel.id)
                else:
                    try:
                        channel_id = int(reponse.content.strip())
                        logs_channel = ctx.guild.get_channel(channel_id)
                        if not logs_channel:
                            await ctx.send("‚ö†Ô∏è Canal de logs introuvable. La fonction de logs sera d√©sactiv√©e.")
                            await self.config.guild(ctx.guild).logs_channel_id.set(None)
                        else:
                            await self.config.guild(ctx.guild).logs_channel_id.set(logs_channel.id)
                    except ValueError:
                        await ctx.send("‚ö†Ô∏è ID de canal invalide. La fonction de logs sera d√©sactiv√©e.")
                        await self.config.guild(ctx.guild).logs_channel_id.set(None)
            else:
                await self.config.guild(ctx.guild).logs_channel_id.set(None)
                
            await ctx.send("‚úÖ Configuration de base termin√©e! Utilisez `!reglement modifier` pour modifier le contenu du r√®glement.")
            
        except asyncio.TimeoutError:
            await ctx.send("‚ùå Temps √©coul√©. Configuration annul√©e.")

    @checks.admin_or_permissions(manage_guild=True)
    @reglement.command(name="modifier")
    async def modifier_reglement(self, ctx):
        """Modifie le contenu du r√®glement (Admin uniquement)"""
        reglement_data = await self.config.guild(ctx.guild).reglement()
        
        await ctx.send("üìù **Modification du r√®glement**\n"
                       "Que souhaitez-vous modifier ?\n"
                       "1Ô∏è‚É£ Introduction\n"
                       "2Ô∏è‚É£ Ajouter une section\n"
                       "3Ô∏è‚É£ Modifier une section existante\n"
                       "4Ô∏è‚É£ Supprimer une section\n"
                       "5Ô∏è‚É£ Conclusion\n"
                       "‚ùå Annuler")
                       
        # Fonction de v√©rification
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
            
        # Attente de la r√©ponse
        try:
            reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
            if reponse.content.lower() == "annuler" or reponse.content == "‚ùå":
                return await ctx.send("‚ùå Modification annul√©e.")
                
            choix = reponse.content
            
            # Introduction
            if choix == "1" or choix == "1Ô∏è‚É£":
                await ctx.send("üìù Veuillez entrer la nouvelle introduction:")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Modification annul√©e.")
                    
                reglement_data["introduction"] = reponse.content
                await self.config.guild(ctx.guild).reglement.set(reglement_data)
                await ctx.send("‚úÖ Introduction modifi√©e avec succ√®s!")
                
            # Ajouter section
            elif choix == "2" or choix == "2Ô∏è‚É£":
                # D√©terminer le num√©ro de section
                section_nums = [int(k) for k in reglement_data["sections"].keys() if k.isdigit()]
                next_section = str(max(section_nums) + 1 if section_nums else 1)
                
                await ctx.send(f"üìù Cr√©ation de la section {next_section}")
                
                await ctx.send("üìù Entrez le titre de cette section:")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Cr√©ation annul√©e.")
                    
                titre = reponse.content
                
                await ctx.send("üìù Entrez le contenu de cette section:")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Cr√©ation annul√©e.")
                    
                contenu = reponse.content
                
                # Ajout de la section
                reglement_data["sections"][next_section] = {
                    "titre": titre,
                    "contenu": contenu
                }
                
                await self.config.guild(ctx.guild).reglement.set(reglement_data)
                await ctx.send(f"‚úÖ Section {next_section} ajout√©e avec succ√®s!")
                
            # Modifier section
            elif choix == "3" or choix == "3Ô∏è‚É£":
                # Afficher les sections disponibles
                sections = "\n".join([f"{num}. {section['titre']}" for num, section in reglement_data["sections"].items()])
                await ctx.send(f"üìù Quelle section souhaitez-vous modifier ?\n{sections}")
                
                reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Modification annul√©e.")
                    
                num_section = reponse.content
                if num_section not in reglement_data["sections"]:
                    return await ctx.send("‚ùå Section introuvable. Modification annul√©e.")
                    
                await ctx.send(f"üìù Modification de la section {num_section}: {reglement_data['sections'][num_section]['titre']}")
                
                await ctx.send("üìù Entrez le nouveau titre (ou `garder` pour conserver l'actuel):")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Modification annul√©e.")
                    
                if reponse.content.lower() != "garder":
                    reglement_data["sections"][num_section]["titre"] = reponse.content
                
                await ctx.send("üìù Entrez le nouveau contenu (ou `garder` pour conserver l'actuel):")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Modification annul√©e.")
                    
                if reponse.content.lower() != "garder":
                    reglement_data["sections"][num_section]["contenu"] = reponse.content
                
                await self.config.guild(ctx.guild).reglement.set(reglement_data)
                await ctx.send(f"‚úÖ Section {num_section} modifi√©e avec succ√®s!")
                
            # Supprimer section
            elif choix == "4" or choix == "4Ô∏è‚É£":
                # Afficher les sections disponibles
                sections = "\n".join([f"{num}. {section['titre']}" for num, section in reglement_data["sections"].items()])
                await ctx.send(f"üìù Quelle section souhaitez-vous supprimer ?\n{sections}")
                
                reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Suppression annul√©e.")
                    
                num_section = reponse.content
                if num_section not in reglement_data["sections"]:
                    return await ctx.send("‚ùå Section introuvable. Suppression annul√©e.")
                    
                # Confirmation
                await ctx.send(f"‚ö†Ô∏è √ätes-vous s√ªr de vouloir supprimer la section {num_section}: {reglement_data['sections'][num_section]['titre']} ? (oui/non)")
                
                reponse = await self.bot.wait_for("message", check=check, timeout=60.0)
                if reponse.content.lower() != "oui":
                    return await ctx.send("‚ùå Suppression annul√©e.")
                    
                # Suppression
                del reglement_data["sections"][num_section]
                
                await self.config.guild(ctx.guild).reglement.set(reglement_data)
                await ctx.send(f"‚úÖ Section {num_section} supprim√©e avec succ√®s!")
                
            # Conclusion
            elif choix == "5" or choix == "5Ô∏è‚É£":
                await ctx.send("üìù Veuillez entrer la nouvelle conclusion:")
                reponse = await self.bot.wait_for("message", check=check, timeout=300.0)
                if reponse.content.lower() == "annuler":
                    return await ctx.send("‚ùå Modification annul√©e.")
                    
                reglement_data["conclusion"] = reponse.content
                await self.config.guild(ctx.guild).reglement.set(reglement_data)
                await ctx.send("‚úÖ Conclusion modifi√©e avec succ√®s!")
            
            else:
                await ctx.send("‚ùå Option invalide. Modification annul√©e.")
                return
                
            # Mise √† jour de la date
            await self.config.guild(ctx.guild).derniere_maj.set(datetime.datetime.now().strftime("%d/%m/%Y"))
                
        except asyncio.TimeoutError:
            await ctx.send("‚ùå Temps √©coul√©. Modification annul√©e.")

    @checks.admin_or_permissions(manage_guild=True)
    @reglement.command(name="publier")
    async def publier_reglement(self, ctx):
        """Publie ou met √† jour le r√®glement dans le canal configur√© (Admin uniquement)"""
        reglement_data = await self.config.guild(ctx.guild).reglement()
        channel_id = await self.config.guild(ctx.guild).reglement_channel_id()
        role_id = await self.config.guild(ctx.guild).role_acceptation_id()
        message_id = await self.config.guild(ctx.guild).reglement_message_id()
        
        if not channel_id:
            return await ctx.send("‚ùå Aucun canal n'a √©t√© configur√© pour le r√®glement. Utilisez `!reglement configurer` d'abord.")
            
        channel = ctx.guild.get_channel(channel_id)
        if not channel:
            return await ctx.send("‚ùå Le canal configur√© est introuvable. Veuillez reconfigurer le r√®glement.")
            
        # Nettoyer le salon en supprimant tous les messages
        await ctx.send("üßπ Nettoyage du salon de r√®glement en cours...")
        try:
            # Supprimer tous les messages du salon
            await channel.purge(limit=100)
            await ctx.send("‚úÖ Salon nettoy√© avec succ√®s.")
        except discord.Forbidden:
            await ctx.send("‚ùå Je n'ai pas la permission de supprimer des messages dans ce salon.")
            return
        except Exception as e:
            await ctx.send(f"‚ùå Une erreur s'est produite lors du nettoyage du salon : {str(e)}")
            return
            
        # Cr√©ation des embeds
        embeds = []
        
        # Embed d'introduction
        intro_embed = discord.Embed(
            title="üìú R√®glement du serveur",
            description=reglement_data["introduction"],
            color=discord.Color.blue()
        )
        intro_embed.set_thumbnail(url=ctx.guild.icon.url if ctx.guild.icon else None)
        
        # Ajouter les sections √† l'embed principal
        for num, section in reglement_data["sections"].items():
            intro_embed.add_field(
                name=f"üìå Section {num}: {section['titre']}",
                value=section["contenu"][:1024],  # Limite de Discord pour les champs d'embed
                inline=False
            )
        
        # Embed de conclusion avec bouton d'acceptation
        conclusion_embed = discord.Embed(
            description=reglement_data["conclusion"],
            color=discord.Color.blue()
        )
        
        derniere_maj = await self.config.guild(ctx.guild).derniere_maj()
        if derniere_maj:
            conclusion_embed.set_footer(text=f"Derni√®re mise √† jour: {derniere_maj}")
            
        embeds = [intro_embed, conclusion_embed]
        
        # Publier le nouveau r√®glement
        try:
            # Envoyer le premier embed (introduction)
            await channel.send(embed=intro_embed)
            
            # Envoyer le dernier embed (conclusion) avec le bouton d'acceptation si un r√¥le est configur√©
            if role_id:
                message = await channel.send(embed=conclusion_embed, view=self.accept_view)
            else:
                message = await channel.send(embed=conclusion_embed)
                
            # Enregistrer l'ID du nouveau message
            await self.config.guild(ctx.guild).reglement_message_id.set(message.id)
            await ctx.send(f"‚úÖ R√®glement publi√© avec succ√®s dans {channel.mention}!")
            
        except Exception as e:
            await ctx.send(f"‚ùå Erreur lors de la publication du r√®glement: {str(e)}")

    @checks.admin_or_permissions(manage_guild=True)
    @reglement.command(name="reboot")
    async def reboot_reglement(self, ctx):
        """R√©initialise le r√®glement aux valeurs par d√©faut (Admin uniquement)"""
        # Demande de confirmation
        await ctx.send("‚ö†Ô∏è **ATTENTION** ‚ö†Ô∏è\nCette commande va r√©initialiser l'int√©gralit√© du r√®glement aux valeurs par d√©faut.\n"
                      "Toutes vos modifications seront perdues.\n\n"
                      "Tapez `confirmer` pour continuer ou toute autre r√©ponse pour annuler.")
                      
        def check(m):
            return m.author == ctx.author and m.channel == ctx.channel
            
        try:
            reponse = await self.bot.wait_for("message", check=check, timeout=30.0)
            if reponse.content.lower() != "confirmer":
                return await ctx.send("‚ùå R√©initialisation annul√©e.")
                
            # R√©initialiser les donn√©es
            await self.config.guild(ctx.guild).clear()
            await ctx.send("‚úÖ Le r√®glement a √©t√© r√©initialis√© aux valeurs par d√©faut.")
            
        except asyncio.TimeoutError:
            await ctx.send("‚ùå Temps √©coul√©. R√©initialisation annul√©e.")

    @reglement.command(name="stats")
    @checks.admin_or_permissions(manage_guild=True)
    async def stats_reglement(self, ctx):
        """Affiche les statistiques du r√®glement (Admin uniquement)"""
        guild_config = self.config.guild(ctx.guild)
        reglement_data = await guild_config.reglement()
        channel_id = await guild_config.reglement_channel_id()
        role_id = await guild_config.role_acceptation_id()
        logs_id = await guild_config.logs_channel_id()
        message_id = await guild_config.reglement_message_id()
        derniere_maj = await guild_config.derniere_maj()
        
        embed = discord.Embed(
            title="üìä Statistiques du r√®glement",
            color=discord.Color.blue(),
            timestamp=datetime.datetime.now()
        )
        
        # Informations g√©n√©rales
        embed.add_field(
            name="üìù Contenu",
            value=f"Sections: {len(reglement_data['sections'])}\n"
                  f"Derni√®re mise √† jour: {derniere_maj or 'Jamais'}", 
            inline=False
        )
        
        # Informations de configuration
        channel = ctx.guild.get_channel(channel_id) if channel_id else None
        role = ctx.guild.get_role(role_id) if role_id else None
        logs_channel = ctx.guild.get_channel(logs_id) if logs_id else None
        
        embed.add_field(
            name="‚öôÔ∏è Configuration",
            value=f"Canal de publication: {channel.mention if channel else 'Non configur√©'}\n"
                  f"R√¥le d'acceptation: {role.mention if role else 'Non configur√©'}\n"
                  f"Canal de logs: {logs_channel.mention if logs_channel else 'Non configur√©'}\n"
                  f"Message ID: {message_id or 'Non publi√©'}",
            inline=False
        )
        
        # Stats du r√¥le
        if role:
            membres_avec_role = len(role.members)
            membres_totaux = ctx.guild.member_count
            pourcentage = (membres_avec_role / membres_totaux) * 100 if membres_totaux > 0 else 0
            
            embed.add_field(
                name="üë• Acceptation",
                value=f"Membres ayant accept√©: {membres_avec_role}/{membres_totaux} ({pourcentage:.1f}%)",
                inline=False
            )
            
        await ctx.send(embed=embed)

async def setup(bot):
    await bot.add_cog(Reglement(bot))

